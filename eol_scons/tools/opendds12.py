#
# Tool for OpenDDS version 1.2 and greater.  
# This will set up appropriate paths to find opendds headers 
# and libraries, and will build the opendds support library. 
#
# The opendds library will contain code compiled from
# sources files that are automatically generated by the 
# tao_idl and dcps_ts.pl tools. 
#
# The reason for this modified version of the opendds tool
# is that the dcps_ts.pl tool, distributed with opendds,
# changed significantly with v1.2. dcps_ts.pl reads the
# project idl file, and produces c++ header and source
# files which provide opendds type support for the 
# data types defined in the idl file. In prior versions,
# each DCPS_DATA_TYPE led to the creation of individual 
# files for that type. Starting with opendds v1.2,
# all of this type support code is placed in a single file.
# It makes this tool significantly simpler, since the 
# idl file does not need to be parsed in order to detect 
# the type names.
#
# There are four steps involved:
# 1. process <idl file> with tao_idl. This will create
#    client and server source files for the data types.
# 2. process <idl file> with dcps_ts.pl. This will create
#    type support source files. It will also create a new
#    idl file.
# 3. Process <new idl file> with tao_idl. This will create 
#    other openddds source files.
# 4. Create a library from the compiled output of all of
#    the generated source files.
#    
import os
import string
import re
from eol_scons.chdir import ChdirActions
from SCons.Variables import PathVariable

_options = None
mykey = "HAS_PKG_OPENDDS"

def generate(env):

  global _options
  if not _options:
    _options = env.GlobalVariables()
    dds_root = env.FindPackagePath('DDS_ROOT', '$OPT_PREFIX/OpenDDS*')
    _options.AddVariables(PathVariable('DDS_ROOT', 'DDS_ROOT directory.', dds_root))
  _options.Update(env)
  
  # Use the existence of a key in the env to separate the DDS tool into
  # what need only be applied once and what must be applied every time this
  # tool is Require()d by another package.  Basically that means the library
  # must always be appended; everything else happens once.

  if not env.has_key(mykey):
    env.Require(['tao', 'ace', 'doxygen'])
    
    dds_root = env['DDS_ROOT']
    env['ENV']['DDS_ROOT'] = dds_root
    
    env.AppendUnique(CPPPATH=[dds_root])
    
    libpath=os.path.join(dds_root, 'lib')
    env.Append(LIBPATH=[libpath, ])
    env.AppendUnique(RPATH=[libpath])

    env.SetDefault(DDS_DOXREF="dds:%s/html/dds" % (dds_root))
    env.AppendDoxref("$DDS_DOXREF")
    env[mykey] = 1

  env.DdsLibrary = DdsLibrary


def exists(env):
    return True

# 
# A DDS project simply defines one or more
# datatypes that will be handled by DDS. This is
# done in an idl file. A raft of supporting
# code and idl is generated from the original
# idl definition of the datatype.
#
# -------------------------------------------
#
# Create a library containing all opendds
# support routines.
#
# @param idlFile The idl file defining the DDS for a particular type 
# @param sources Sources to be compiled into the library, in addition to
#    those automatically generated from the IDL file
def DdsLibrary(idlFile, env, sources=[]):
    # get our current directory relative to the top level, needed
    # for some later commands which must be executed here.
    curDir = env.Dir('.').get_path(env.Dir('#'))
    execHerePrefix = "cd %s && " % curDir
    #
    # get the OpenDDS version fields
    (major, minor, micro) = openDDSVersion(env)
    # DDSversion will be an integer of the form xxyyzz
    # So we are counting on none of the version fields being greater than 9.
    DDSversion = major * 10000 + minor * 100 + micro
    #
    # Perform the idl processing steps. This amounts to:
    #  1. tao_idl -Gdcps file.idl  # (no -Gdcps in latter versions of OpenDDS)
    #  2. dcps_ts.pl     file.idl  # (opendds_idl instead of dcps_ts.pl in latter versions of OpenDDS)
    #  3. tao_idl        fileTypeSupport.idl
    #  4. compile the generated products and create a library
    #
    # 1. ------------------------------------------
    #
    # create a target list of files produced by the tao_idl 
    # processing of the main idl. There will be three sublists:
    #[[*.cpp], [*.h], [*.inl]]
    target1 = taoIdlFiles(idlFile)
    #
    # Now process the main idl file with tao_idl
    # The -Gdcps switch is used for OpenDDS versions less than 2.2.0
    if DDSversion < 20200:
    	cmd = env['TAO_IDL'] + ' -o $SOURCE.dir -Gdcps $SOURCE'
    else:
    	cmd = env['TAO_IDL'] + ' -o $SOURCE.dir $SOURCE'
    env.Command(target1, idlFile, cmd)
    #
    # 2. ------------------------------------------
    #
    # get a list of files produced by the dcps_ts processing of
    # the type support idl files. There will be three sublists:
    #[[*.cpp], [*.h], [*.idl]]  (Note the idl output)
    target2 = dcpsTsFiles(idlFile)
    #
    #
    # Process the main idl file with dcps_ts.pl or opendds_idl.
    # The latter is used for OpenDDS v2.2 and greater
    if DDSversion < 20200:
    	dcps_idl_processor = 'dcps_ts.pl'
    else:
        dcps_idl_processor = 'opendds_idl'
    # Execute the dcp_tl.pl command in the current directory.
    cmd = os.path.join(env['DDS_ROOT'], 'bin', dcps_idl_processor)
    dcpsCmd = ChdirActions(env, [cmd + " $SOURCE.file"], curDir)
    env.Command(target2, idlFile, dcpsCmd)
    #
    # 3. ------------------------------------------
    #
    # Process the generated type support idl file using tao_idl
    tao_cmd = ChdirActions(env, [env['TAO_IDL'] + ' -I ' + env['DDS_ROOT'] +
                                 ' $SOURCE.file'], curDir)
    typeSupportIdlFile = target2[2][0]
    target3 = taoIdlFiles(typeSupportIdlFile)
    env.Command(target3, typeSupportIdlFile, tao_cmd)
    #
    # 4. ------------------------------------------
    #
    # Collect all of the source files, which will be compiled for the
    # library
    sources += target1[0] + target2[0] + target3[0]
    headers = target1[1] + target2[1] + target3[1]
    #
    # library name is the same as the IDL file base name, with the
    # .idl extension removed
    libName = os.path.splitext(os.path.basename(idlFile))[0]
	#
    # Return the library itself, and also a list of source and header files
    # used to generate it (for documentation purposes)
    return [env.Library(libName, sources), sources, headers]

# -------- DDS support functions -----------
#
# Two functions are provided here which generate all of the file names
# associated with a a DDS project. These are taoIdlFiles() and
# dcpsTsFiles(). These functions create all of the filenames that will be
# created by the tao_idl and the dcps_ts.pl processors.
#
# These functions are used by the DsdLibrary() function.
#
# -------------------------------------------
#
# Create the filenames that are produced by tao_idl -Gdcps processing.

# @param idlFile The name of the idl file
# @return A 3 element list. The first slice contains a list of .cpp
# files. The second slice contains a list of .h files. The third slice
# contains a list of .inl files.
def taoIdlFiles(idlFile):
    root     = idlFile.split('.')[0]
    cppFiles = [root+'C.cpp', root+'S.cpp']
    hFiles   = [root+'C.h', root+'S.h']
    inlFiles = [root+'C.inl']
    return [cppFiles, hFiles, inlFiles]

# Create the filenames that are produced by dcps_ts.pl processing.
#
# @param idlFile The name of the idl file
# @return A 3 element list. The first slice contains a .cpp
# file. The second slice a .h file. The third slice
# contains an .idl file.
def dcpsTsFiles(idlFile):
    root    = idlFile.split('.')[0]
    cppFile = [root+'TypeSupportImpl.cpp',]
    hFile   = [root+'TypeSupportImpl.h',]
    idlFile = [root+'TypeSupport.idl',]
    return [cppFile, hFile, idlFile]

# Determine the OpenDDS version and return a the list [major, minor, micro]
def openDDSVersion(env):
	major = 0
	minor = 0
	micro = 0
	version_h = env['DDS_ROOT']+'/dds/Version.h'
	fd = open(version_h,'r')
	versionContents = fd.readlines()
	fd.close()
	for line in versionContents:
		l = line.split()
		if len(l) == 3:
			if l[1] == 'DDS_MAJOR_VERSION':
				major = int(l[2])
			if l[1] == 'DDS_MINOR_VERSION':
				minor = int(l[2])
			if l[1] == 'DDS_MICRO_VERSION':
				micro = int(l[2])
	return (major, minor, micro)
	
