# Copyright (c) 2007-present, NSF NCAR, UCAR
#
# This source code is licensed under the MIT license found in the LICENSE
# file in the root directory of this source tree.
"""
Methods for creating and installing versioned shared libraries and the
associated symbolic links.  The SCons built-in builders SharedLibrary() and
InstallVersionedLib() now seem to work same as these builders, in which case
it should be possible to deprecate these custom builders.
"""

import os
import re
from typing import Tuple
from symlink import MakeSymLink
from SCons.Script import Builder, Environment
import SCons.Defaults
import SCons.Scanner.Prog


def _extract_shlibversions_from_tag(tag: str) -> Tuple[int, int] or None:
    """
    Tag is expected in the form v(MMM).(NNN)(-xxx|.PPP), where MMM is the
    major version, NNN is the minor version, PPP is a patchlevel, and xxx can
    be some other string, like a pre-release.  The fields can be one or more
    digits.  This tool only supports two shared library version numbers, a
    major and a minor.  Return the versions as a tuple of int (major, minor),
    or None if the tag could not be parsed.
    """
    rx = re.match(r"[Vv]([0-9]+)\.([0-9]+)([-.].*)?", tag)
    if rx:
        return (int(rx.group(1)), int(rx.group(2)))
    return None


def GetArchLibDir(env):
    # ARCHLIBDIR can be used if the user wants to install libraries
    # to a special directory for the architecture, like lib64
    #
    # It is tempting to pass clean=False and help=False to this Configure
    # context, but that might change the paths to targets which need to be
    # cleaned or are specified in help variables.

    sconf = env.Clone(LIBS=[]).Configure()
    libdir = 'lib'
    if sconf.CheckTypeSize('void *', expect=8, language='C'):
        libdir = 'lib64'
    env['ARCHLIBDIR'] = libdir
    sconf.Finish()
    return libdir


def SharedLibrary3Emitter(target, source, env: Environment):
    """
    Given a shared library name as the target in the form libname.so, append
    targets for the versioned soname and versioned fullname.

    This emitter returns three targets in this order:
        libxxx.so, libxxx.so.X, and libxxx.so.X.Y
    """
    libname = str(target[0])
    env.LogDebug("SharedLibrary3Emitter(libname=%s, source=%s, env=%s)" %
                 (libname, source[0], env.Dir('.')))

    if env.get("SHLIBMAJORVERSION"):
        env.LogDebug("using existing setting: SHLIBMAJORVERSION=%s" %
                     (env.get("SHLIBMAJORVERSION")))
    elif env.get("REPO_TAG"):
        rev = _extract_shlibversions_from_tag(env["REPO_TAG"])
        if rev:
            env["SHLIBMAJORVERSION"] = rev[0]
            env["SHLIBMINORVERSION"] = rev[1]
            env.LogDebug("Set SHLIBMAJORVERSION=%s and SHLIBMINORVERSION=%s "
                         "from REPO_TAG=%s" %
                         (env.get('SHLIBMAJORVERSION'),
                          env.get('SHLIBMINORVERSION'), env.get('REPO_TAG')))
        else:
            print("*** could not parse SHLIB versions from REPO_TAG=%s ***" %
                  (env.get('REPO_TAG')))

    if not env.get("SHLIBMAJORVERSION"):
        print("*** No setting for SHLIBMAJORVERSION or REPO_TAG! ***")

    soname = env.subst(libname + ".${SHLIBMAJORVERSION}")
    fullname = env.subst(soname + ".${SHLIBMINORVERSION}")
    env.LogDebug("emitting libname=%s, soname=%s, fullname=%s" %
                 (libname, soname, fullname))
    return ([libname, soname, fullname], source)


def SharedLibrary3Action(target, source, env):
    """
    Action to build a shared library and symbolic links.

    The targets generated by the above emitter are:
    target[0] = libxxx.so       short name
    target[1] = libxxx.so.X     soname
    target[2] = libxxx.so.X.Y   full library

    SHLINKCOM is the action used by the SharedLibrary builder.
    """
    soname = os.path.basename(target[1].path)

    env.Append(SHLINKFLAGS=['-Wl,-soname=' + soname])

    # Execute the shared library action to build the full library
    if env.Execute(env.subst('$SHLINKCOM', target=target[2], source=source)):
        errstr = "%s failed" % env.subst('$SHLINKCOM')
        raise SCons.Errors.BuildError(node=target[2], errstr=errstr)

    # Now use the action of the SymLink builder to create
    # symbolic links from libxxx.so.X.Y to libxxx.so.X and libxxx.so
    MakeSymLink([target[0]], [target[2]], env)
    MakeSymLink([target[1]], [target[2]], env)
    return 0


def SharedLibrary3Install(env, target, source, **kw):
    """
    Install source library to a library subdirectory of target.
    If env["ARCHLIBDIR"] is defined, the source will be installed
    to target/$ARCHLIBDIR, otherwise to target/lib.

    See the discussion for SharedLibrary3 about how library versions 
    are handled.

    source[0] is the target returned from SharedLibrary3, which is the
    short name of the library: libxxx.so

    If source[1] exists, it is assumed to be the second target
    returned from SharedLibrary3, which is the "soname":
    libxxx.so.X

    If source[2] exists, it is assumed to be the third target
    returned from SharedLibrary3, which is the full library name:
    libxxx.so.X.Y

    This installer will copy libxxx.so.X.Y to target/lib[64],
    and then create symbolic links on the target lib directory:
        libxxx.so -> libxxx.so.X.Y
        libxxx.so.X -> libxxx.so.X.Y
    """
    # add passed keywords to environment
    env = env.Clone(**kw)

    if "ARCHLIBDIR" in env:
        targetDir = env.Dir(target + '/' + env['ARCHLIBDIR'])
    else:
        targetDir = env.Dir(target + '/lib')

    libname = str(source[0])

    if len(source) > 1:
        soname = str(source[1])
    else:
        soname = libname + '.${SHLIBMAJORVERSION}'

    if len(source) > 2:
        fullname = str(source[2])
    else:
        fullname = soname + '.${SHLIBMINORVERSION}'

    # If --install-sandbox is in effect, then the library may be installed
    # into a different directory than specified.  So use the directory of the
    # returned target to get the location of the symlinks.  And use the string
    # form of targetDir instead of node so the sandbox directory is applied.
    libfull = env.Install(targetDir.abspath, fullname)[0]
    tgt = libfull.dir.File(os.path.basename(libname))
    liblink = env.SymLink(tgt, fullname)[0]
    tgt = libfull.dir.File(os.path.basename(soname))
    solink = env.SymLink(tgt, fullname)[0]
    # return list of targets which can then be used in an Alias
    return [libfull, liblink, solink]


def generate(env: Environment):
    """
    Builder and Installer for shared libraries and their symbolic links.

    Usage:
        # GitInfo tool can be used to set REPO_TAG in environment
        env.GitInfo("include/revision.h", "#")

        # If REPO_TAG is in the form "vX.Y" or "VX.Y", where X and Y are
        # integers, then this generate function will set
            env["SHLIBMAJORVERSION"] = X
            env["SHLIBMINORVERSION"] = Y

        # If not using GitInfo, set SHLIBMAJORVERSION and SHLIBMINORVERSION
        # by hand
        if not env.has_key("REPO_TAG"):
            env["SHLIBMAJORVERSION"] = "3"
            env["SHLIBMINORVERSION"] = '5'

        # if modules in libfoo.so use symbols from libbar.so, add LIBS=['bar']
        libs = env.SharedLibrary3('foo',['foo.c'],
            LIBS=['bar'],LIBPATH=['/opt/bar/lib'])
        env.SharedLibrary3Install('/opt/foo',libs)

    The SharedLibrary3 builder above will create one library and two
    symbolic links to it:
    1. actual library file, libfoo.so.3.5
    2. symbolic link: libfoo.so.3 -> libfoo.so.3.5
    3. symbolic link: libfoo.so -> libfoo.so.3.5

    The SharedLibrary3Install statement will install the library and
    its links on /opt/foo/$ARCHLIBDIR.

    If ARCHLIBDIR is not pre-defined it will set to 'lib64' on 64 bit systems
    'lib' on 32 bit systems.

    For a reference on Linux conventions for shared library names see
    http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html

    The usual convention is that the full library name is something like:
        libxxx.so.X.Y
    Where X is the major version number of the binary API and Y is the minor
    version.

    The SONAME of the library is
        libxxx.so.X
    The basic library name, used when initially linking executables, is
        libxxx.so

    Under linux, libxxx.so.X.Y is typically the actual library file,
    and libxxx.so.X and libxxx.so are symbolic links.

    The idea is that two libraries with the same name, same major
    number, but differing minor number, implement the same binary API, and
    that a library with a new minor number could replace the old
    without breaking executable programs that depend on the library.

    From the man page of ld, discussing the -soname option:
    -soname=name
        When creating an ELF shared object, set the internal DT_SONAME field
        to the specified name.  When an executable is linked with a shared
        object which has a DT_SONAME field, then when the executable is run
        the dynamic linker will attempt to  load  the  shared object specified
        by the DT_SONAME field rather than the using the file name given to
        the linker.

    If the SONAME of a library contains just the major version number, and a
    a symbolic link exists with a name equal to the SONAME, pointing
    to the real library file, then a new library file could be installed
    with a different minor number, and the symbolic link updated to point
    to the new library, without re-linking executables.  This will only work
    if the binary APIs of libraries with the same major number are compatible.

    The SONAME of a library can be seen with
        objdump -p libxxx.so | grep SONAME

    ldd lists the SONAMEs of the libraries that a program was linked against.
    rpmbuild uses the same tools as ldd, and creates dependencies for
    executables based on the SONAMEs of the linked libraries.

    If the library has a SONAME, then the basic library name, libxxx.so,
    without major and minor numbers, is only used when linking executables
    with the -lxxx option.  That is why symbolic link .so's, without major
    and minor numbers, are sometimes found only in -devel RPMs.

    To create the above three libraries with this builder, set "REPO_TAG",
    or "SHLIBMAJORVERSION" and "SHLIBMINORVERSION" in the environment:

        env['REPO_TAG'] = 'v3.4'
        # or
        env['SHLIBMAJORVERSION'] = '3'
        env['SHLIBMINORVERSION'] = '4'

        lib = env.SharedLibrary3('xxx',objects)

    This builder will set the -soname in the real library file, and the other
    two will be symbolic links.

    To install the library and the symbolic links to a destination:

        env.SharedLibrary3Install('/opt/mystuff',lib)

    If the environment token ARCHLIBDIR not defined, it will be set to
    "lib64" on 64 bit systems and "lib" on 32.

    In the install step, the libraries will be installed in
    /opt/mystuff/env['ARCHLIBDIR'].

    As of this writing, this builder has only been tested on Linux.
    Support for other architectures needs to be added as necessary.

    One potential issue is whether there should be dots between the
    library suffix and the major and minor version numbers in the
    library file name.
    """
    # Special builder for shared libraries.  Some of these build parameters
    # were stolen from the definition of the SharedLibrary builder in
    # /usr/lib/scons/SCons/Tool/__init__.py.  The version suffixes are added
    # by the emitter rather than adding them here, so the emitter does not
    # need to parse the versions from the library suffix.
    builder = Builder(
            action=[SCons.Defaults.SharedCheck, SharedLibrary3Action],
            emitter=SharedLibrary3Emitter,
            prefix='${SHLIBPREFIX}',
            suffix='${SHLIBSUFFIX}',
            target_scanner=SCons.Scanner.Prog.ProgramScanner(),
            src_suffix='${SHOBJSUFFIX}',
            src_builder='SharedObject'
            )
    env.Append(BUILDERS={"SharedLibrary3": builder})
    env.AddMethod(SharedLibrary3Install)
    if 'ARCHLIBDIR' not in env:
        GetArchLibDir(env)


def exists(env):
    return 1
